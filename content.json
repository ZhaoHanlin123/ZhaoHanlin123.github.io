{"meta":{"title":"日常点滴","subtitle":"改变自己","description":"","author":"赵含霖","url":"http://yoursite.com","root":"/"},"pages":[{"title":"分类","date":"2020-01-29T05:48:47.000Z","updated":"2020-01-29T05:50:12.730Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-01-29T05:33:20.000Z","updated":"2020-01-29T05:47:22.595Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"pytorch自建数据集","slug":"pytorch自建数据集","date":"2020-02-07T08:29:45.000Z","updated":"2020-02-07T10:28:29.722Z","comments":true,"path":"2020/02/07/pytorch自建数据集/","link":"","permalink":"http://yoursite.com/2020/02/07/pytorch%E8%87%AA%E5%BB%BA%E6%95%B0%E6%8D%AE%E9%9B%86/","excerpt":"","text":"在pytorch的学习过程中，一般直接使用下载的数据集进行学习，但在自己实际进行搭建的时候，发现如何对如何构建数据集还是有些疑惑，所以总结一些方法如下 1.ImgaeFolder首先建立train和test文件夹，每个文件夹下按照按照类别名创建文件夹，在里面储存相应的照片 1234567root&#x2F;train&#x2F;dog&#x2F;001.pngroot&#x2F;train&#x2F;dog&#x2F;002.pngroot&#x2F;train&#x2F;dog&#x2F;003.pngroot&#x2F;train&#x2F;cat&#x2F;001.pngroot&#x2F;train&#x2F;cat&#x2F;002.pngroot&#x2F;train&#x2F;cat&#x2F;003.png root为路径，上面表示数据集已经按类分好，在train文件下有dog和cat两类数据，在一个文件夹内是同一类的图片。通过torchvision.datasets.ImageFolder模块进行导入 12import torchvision.datasets as dsetdset.ImageFolder(root=\"root folder path\", [transform, target_transform]) 参数： root ： 指定图片存储的路径，在下面的例子中是’./data/dogcat_2’ transform： 一个函数，原始图片作为输入，返回一个转换后的图片。 target_transform - 一个函数，输入为target，输出对其的转换。例子，输入的是图片标注的string，输出为word的索引。 返回有以下成员变量: self.classes - 用一个list保存 类名 self.class_to_idx - 类名对应的 索引 self.imgs - 保存(img-path, class) tuple的list 12345678import torchimport torchvision.datasets as dsettrain_set = dset.ImageFolder(\"train\")print(train_set.classes) #根据分的文件夹的名字来确定的类别print(train_set.class_to_idx) #按顺序为这些类别定义索引为0,1...print(train_set.imgs) #返回从所有文件夹中得到 返回 123['cat', 'dog']&#123;'cat': 0, 'dog': 1&#125;[('train\\\\cat\\\\001.jpg', 0), ('train\\\\cat\\\\002.jpg', 0), ('train\\\\cat\\\\003.jpg', 0), ('train\\\\dog\\\\001.jpg', 1), ('train\\\\dog\\\\002.jpg', 1), ('train\\\\dog\\\\003.jpg', 1)] 2 重写Dataset类pytorch中Dataset类的源码12345678910111213141516class Dataset(object):\"\"\"An abstract class representing a Dataset.All other datasets should subclass it. All subclasses should override``__len__``, that provides the size of the dataset, and ``__getitem__``,supporting integer indexing in range from 0 to len(self) exclusive.\"\"\" #这个函数就是根据索引，迭代的读取路径和标签。因此我们需要有一个路径和标签的 ‘容器’供我们读def __getitem__(self, index): raise NotImplementedError #返回数据的长度def __len__(self): raise NotImplementedErrordef __add__(self, other): return ConcatDataset([self, other]) 我们要想让自己创建的数据集能被DataLoader读取，就要重写Dataset类，重点是重新实现__getitem__和__len__两个方法 将图像的路径和标签保存到txt文件中去，下面列子中以py文件所在的目录为工作目录，因此要计算好路径 txt文件内容123456train&#x2F;cat&#x2F;001.jpg 0train&#x2F;cat&#x2F;002.jpg 0train&#x2F;cat&#x2F;003.jpg 0train&#x2F;dog&#x2F;001.jpg 1train&#x2F;dog&#x2F;002.jpg 1train&#x2F;dog&#x2F;003.jpg 1 重新实现Dataset类的__getitem__和__len__两个方法12345678910111213141516171819202122232425262728293031323334353637383940from PIL import Imagefrom torch.utils.data import Dataset, DataLoaderfrom torchvision import transformsclass MyDataset(Dataset): def __init__(self, datatxt, transform=None, target_transform=None): # 初始化需要传入的参数 super(MyDataset, self).__init__() fh = open(datatxt, 'r') imgs = [] # 创建一个空列表，来存入读入的图片 for line in fh: # 循环按行读取txt文件 line = line.rstrip() # 删除 本行string 字符串末尾的指定字符，这个方法的详细介绍自己查询python words = line.split() imgs.append((words[0], words[1])) # 前面为图片的路径，后面为图片的标签 self.imgs = imgs self.transform = transform self.target_transform = target_transform def __getitem__(self, index): \"\"\" 按索引读取每个元素的具体内容 \"\"\" fn, label = self.imgs[index] # fn为图片路径，label为图片标签 img = Image.open(fn).convert('RGB') if self.transform is not None: # 是否进行transform img = self.transform(img) return img, label # 返回图像和标签 def __len__(self): return len(self.imgs)train_set = MyDataset('trainset.txt', transform=transforms.ToTensor())train_loader = DataLoader(dataset=train_set, batch_size=1)# 取一个batchtrain_iter = iter(train_loader)imgs, label = next(train_iter) # 读取图片print(imgs.size()) # batch_size, channel, height, weightprint(label) 12torch.Size([1, 3, 333, 500])('0',)","categories":[],"tags":[{"name":"pytorch 深度学习","slug":"pytorch-深度学习","permalink":"http://yoursite.com/tags/pytorch-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"}]},{"title":"vscode配置C++环境","slug":"vscode配置C++环境","date":"2020-01-30T13:26:12.000Z","updated":"2020-02-01T06:27:07.387Z","comments":true,"path":"2020/01/30/vscode配置C++环境/","link":"","permalink":"http://yoursite.com/2020/01/30/vscode%E9%85%8D%E7%BD%AEC++%E7%8E%AF%E5%A2%83/","excerpt":"Visual Studio Code（以下简称vscode）是一个轻量且强大的跨平台开源代码编辑器（IDE），支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。","text":"Visual Studio Code（以下简称vscode）是一个轻量且强大的跨平台开源代码编辑器（IDE），支持Windows，OS X和Linux。内置JavaScript、TypeScript和Node.js支持，而且拥有丰富的插件生态系统，可通过安装插件来支持C++、C#、Python、PHP等其他语言。其实环境的配置，VS code提供的文档已经十分清楚了，建议大家先看看文档，再从网上查找相关的资料，更容易理解， Microsoft的C/C++扩展是针对C/C++代码编辑的，其中包括： C/C++代码智能感知； C/C++代码调试（需要配合已安装的调试器）； C/C++代码浏览； C/C++扩展不包括C/C++编译器和调试器，需要在电脑上提前安装C/C++编译工具链，可以在vscode搜索安装插件C/C++编译工具链可以选择MinGW-W64。 因此，要想通过vscode进行c/c++开发，首先要安装MinGW和vscode。具体步骤请看安装细节，并配置好环境变量。 个人认为配置过程的难点在于配置task.json和launch.json文件上，虽然有很多博客已经配置好，只需将编译器的路径修改为自己的路径即可，但我还是有些不明白，因此废了一些时间，所以对初学者分享一下经验。 1 创建工作区VS Code以文件夹作为工作区，所以创建工作区有两种方式： 在Windows命令行进入文件夹，使用命令code .打开文件夹，创建工作区； 先打开VS Code，然后使用VS Code打开文件夹，创建工作区； 我现在桌面创建test文件夹。然后右键点击文件夹，选择用VS code打开，也可以打开VS code后，点击左上角文件，选择打开文件夹，选择打开test文件夹。 2 创建代码在test文件夹下新文件，命名为helloworld.cpp，编辑测试代码 12345678#include &lt;iostream&gt;using namespace std;int main()&#123; cout &lt;&lt; \"hello world\\n\"; system(\"pause\");&#125; 3 编译调制设置3.1 配置编译器路径使用Ctrl+Shift+P打开命令面板，输入C/C++，推荐列表中有UI方式和JSON格式的两种编辑配置方式，如图（这里我们选择Edit configurations(JSON)） VS Code会自动在工作区中的.vscode目录下创建c_cpp_properties.json文件，这个文件是一个JSON格式文件，用来指定编译器路径和语言标准，其原始内容如下： 1234567891011121314151617181920&#123; \"configurations\": [ &#123; \"name\": \"Win32\", \"includePath\": [ \"$&#123;workspaceFolder&#125;/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"D:\\\\software\\\\MinGW\\\\bin\\\\gcc.exe\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"clang-x86\" &#125; ], \"version\": 4&#125; compilerPath：应修改为为当前系统中g++编译器（对C,为gcc）所在的路径，因此我应该将其修改为: 1\"D:\\\\software\\\\MinGW\\\\bin\\\\g++.exe\" cStandard, cppStandard：选择编译器使用的C/C++语言标准。 intelliSenseMode：是IntelliSense功能的设置，这里我们设置为gcc-x64，有助于IntelliSense功能根据编译器所在的路径来自动推断C/C++标准库头文件的路径，以提供正确的路径。 includepath：设置程序中包含不在当前工作区或者标准库路径中的头文件。 最后完整配置 1234567891011121314151617181920&#123; \"configurations\": [ &#123; \"name\": \"Win32\", \"includePath\": [ \"$&#123;workspaceFolder&#125;/**\" ], \"defines\": [ \"_DEBUG\", \"UNICODE\", \"_UNICODE\" ], \"compilerPath\": \"D:\\\\software\\\\MinGW\\\\bin\\\\g++.exe\", \"cStandard\": \"c11\", \"cppStandard\": \"c++17\", \"intelliSenseMode\": \"gcc-x64\" &#125; ], \"version\": 4&#125; 3.2 创建构建任务在配置完gcc编译器路径后，需要创建一个tasks.json文件来告诉VS Code如何构建（编译）程序，此任务将调用gcc编译器基于源代码创建可执行文件。 按Ctrl+Shift+P调出命令面板，输入task，选择Tasks:Configure Default Build Task。 选择g++.exe build active file，创建出task文件如下 12345678910111213141516171819202122232425262728&#123;// 有关 tasks.json 格式的文档，请参见 // https://go.microsoft.com/fwlink/?LinkId=733558 \"version\": \"2.0.0\", \"tasks\": [ &#123; \"type\": \"shell\", \"label\": \"g++.exe build active file\", \"command\": \"D:\\\\software\\\\MinGW\\\\bin\\\\g++.exe\", \"args\": [ \"-g\", \"$&#123;file&#125;\", \"-o\", \"$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe\" ], \"options\": &#123; \"cwd\": \"D:\\\\software\\\\MinGW\\\\bin\" &#125;, \"problemMatcher\": [ \"$gcc\" ], \"group\": &#123; \"kind\": \"build\", \"isDefault\": true &#125; &#125; ]&#125; 替换为 12345678910111213141516171819202122232425262728293031323334353637&#123;// See https://go.microsoft.com/fwlink/?LinkId=733558// for the documentation about the tasks.json format\"version\": \"2.0.0\",\"tasks\": [ &#123; \"type\": \"shell\", \"label\": \"g++\", //这里注意一下，见下文 \"command\": \"D:\\\\Environment\\\\MinGW\\\\bin\\\\g++.exe\", \"args\": [ \"-g\", \"$&#123;file&#125;\", \"-o\", \"$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe\", \"-ggdb3\", // 生成和调试有关的信息 \"-Wall\", // 开启额外警告 \"-static-libgcc\", // 静态链接 \"-std=c++17\", // 使用c++17标准 \"-finput-charset=UTF-8\", //输入编译器文本编码 默认为UTF-8 \"-fexec-charset=GB18030\", //输出exe文件的编码 \"-D _USE_MATH_DEFINES\" ], \"options\": &#123; \"cwd\": \"D:\\\\Environment\\\\MinGW\\\\bin\" &#125;, \"problemMatcher\": [ \"$gcc\" ], \"presentation\": &#123; \"echo\": true, \"reveal\": \"always\", // 在“终端”中显示编译信息的策略，可以为always，silent，never \"focus\": false, \"panel\": \"shared\" // 不同的文件的编译信息共享一个终端面板 &#125;, &#125;]&#125; label：指定该任务的名称，后续会在VS Code Command Palette(控制面板)中看到；比如将设置&quot;label&quot;: &quot;helloworld&quot;，则在控制面板中可以看到已配置的任务”helloworld”。 command：指定要运行的程序； args：指定传递给gcc的命令行参数，注意这些参数必须按照编译器指定的顺序排列 此外，VS code中的预定义变量，在配置文件的时候可能会需要，简单介绍如下。 ${workspaceRoot}：当前打开的文件夹的绝对路径+文件夹的名字 ${workspaceRootFolderName}：当前打开的文件夹的名字 ${file}：当前打开正在编辑的文件名，包括绝对路径，文件名，文件后缀名 ${relativeFile}：从当前打开的文件夹到当前打开的文件的路径如 当前打开的是test文件夹，当前的打开的是main.c，并有test / first / second / main.c，那么此变量代表的是 first / second / main.c ${fileBasename}：当前打开的文件名+后缀名，不包括路径 ${fileBasenameNoExtension}：当前打开的文件的文件名，不包括路径和后缀名 ${fileDirname}：当前打开的文件所在的绝对路径，不包括文件名 ${fileExtname}：当前打开的文件的后缀名 ${lineNumber}：当前文件光标所在的行号 ${env:PATH}：系统中的环境变量 如tasks.json文件中&quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;相当于设置创建后的可执行文件的路径。此时生成可执行文件应该与.cpp文件处于同一目录下。如果在当前目录下创建exe文件夹，并将生成可执行文件的路径修改为&quot;${fileDirname}\\\\exe\\\\${fileBasenameNoExtension}.exe&quot;，则生成的可执行文件在exe文件夹内。 3.3 配置调试设置通过task.json文件后，已经可以生成可执行文件.exe。，接下来我们配置调试设置，使得按下F5之后VS Code会自动启动gcc调试器（gdb.exe）。 选择调试一栏，然后点击设置按钮： 选择C++(GDB/LLDB) 选择g++.exe build and debug active file 选中后VS Code会自动在.vscode下生成launch.json文件，该文件指定了调试器的设置，其默认内容如下： 1234567891011121314151617181920212223242526272829&#123;// 使用 IntelliSense 了解相关属性。// 悬停以查看现有属性的描述。// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\"version\": \"0.2.0\",\"configurations\": [ &#123; \"name\": \"g++.exe build and debug active file\", \"type\": \"cppdbg\", \"request\": \"launch\", \"program\": \"$&#123;fileDirname&#125;\\\\$&#123;fileBasenameNoExtension&#125;.exe\", \"args\": [], \"stopAtEntry\": false, \"cwd\": \"$&#123;workspaceFolder&#125;\", \"environment\": [], \"externalConsole\": false, \"MIMode\": \"gdb\", \"miDebuggerPath\": \"D:\\\\software\\\\MinGW\\\\bin\\\\gdb.exe\", \"setupCommands\": [ &#123; \"description\": \"为 gdb 启用整齐打印\", \"text\": \"-enable-pretty-printing\", \"ignoreFailures\": true &#125; ], \"preLaunchTask\": \"g++.exe build active file\" &#125;]&#125; program: 指定要debug的可执行程序的名称；注意要与tasks.json文件中生成的可执行文件路径相同。 stopAtEntry: 启动调试时自动停止在程序入口第一行main，可设置为true或false； miDebuggerPath：指定gdb调试器的路径，在我电脑上为D:\\\\software\\\\MinGW\\\\bin\\\\gdb.exe； 4.构建程序创建了构建任务tasks.json，有两种运行方式可以执行构建任务： 直接按Ctrl+Shift+B（需要将任务设置为默认）； 在命令面板中输入task，然后选择运行构建任务；任务执行后，在集成终端窗口中会显示编译器的输出，指示构建成功或者失败，对于成功的构建，输出如下： 在终端输出消息后，按任意键关闭构建消息。 构建任务运行后，如果构建成功，在当前工作区会生成我们在构建任务中指定的可执行程序. 5.启动调试会话启动调试有两种方式： 直接按F5； 选择调试-&gt;启动调试 参考文献https://blog.csdn.net/qq_40477151/article/details/103917156https://blog.csdn.net/Mculover666/article/details/89843448https://www.zhihu.com/question/30315894https://blog.csdn.net/bailsong/article/details/77527773","categories":[{"name":"c++","slug":"c","permalink":"http://yoursite.com/categories/c/"}],"tags":[{"name":"c++ vscode","slug":"c-vscode","permalink":"http://yoursite.com/tags/c-vscode/"}]},{"title":"torchvision模块介绍","slug":"torchvision模块介绍","date":"2020-01-28T03:38:40.000Z","updated":"2020-01-30T02:18:32.346Z","comments":true,"path":"2020/01/28/torchvision模块介绍/","link":"","permalink":"http://yoursite.com/2020/01/28/torchvision%E6%A8%A1%E5%9D%97%E4%BB%8B%E7%BB%8D/","excerpt":"torchvision是独立于pytorch的关于图像操作的一些方便工具库。","text":"torchvision是独立于pytorch的关于图像操作的一些方便工具库。torchvision主要包括一下几个包： torchvision.datasets: 一些加载数据的函数及常用的数据集接口。 torchvision.models：包含常用的模型结构（含预训练模型）和训练好的参数，例如AlexNet、VGG、ResNet等。 torchvision.transforms: 常用的图片变换，例如裁剪、旋转等。 torchvision.utils: 其他的一些有用的方法。 具体代码可以参考github 1 torchvision.datasets1.1 下载以后的数据集所有数据集都是torch.utils.data.Dataset的子类，都含有__getitem__和__len__方法。因此，它们都可以传递给torch.utils.data.DataLoader，使用torch.multiprocessing可以并行加载多个样本。例如： 12345imagenet_data = torchvision.datasets.ImageNet('path/to/imagenet_root/')data_loader = torch.utils.data.DataLoader(imagenet_data, batch_size=4, shuffle=True, num_workers=args.nThreads) 包括以下数据集 MNIST Fashion-MNIST KMNIST EMNIST FakeData COCO Captions Detection LSUN ImageFolder DatasetFolder Imagenet-12 CIFAR STL10 SVHN PhotoTour SBU Flickr VOC Cityscapes SBD 每个数据集都有相似的参数，在掌握一个后很容易掌握其他数据集。 1torchvision.datasets.MNIST(root, train=True, transform=None, target_transform=None, download=False) root:数据的目录，里边有 processed/training.pt 和processed/test.pt 的内容train: True-使用训练集, False-使用测试集.transform: 给输入图像施加变换target_transform: 给目标值(类别标签)施加的变换download: 是否下载mnist数据集,首次使用时需要下载为True。示例: 12345import torchvisionimport torchvision.transforms as transformsMNIST_train = torchvision.datasets.MNIST('Datasets/MNIST', train=True, transform=transforms.ToTensor(), target_transform=None, download=False)MNIST_test = torchvision.datasets.MNIST('Datasets/MNIST', train=False, transform=transforms.ToTensor(), target_transform=None, download=False) 通过len()获得数据集大小，通过下标来获得具体的个数 12345print(type(MNIST_train))print(len(MNIST_train), len(MNIST_test))feature, label = MNIST_train[0]print(feature.shape, label) 123&lt;class 'torchvision.datasets.mnist.MNIST'&gt;60000 10000torch.Size([1, 28, 28]) 5 1.2 ImageFolder1234567root&#x2F;dog&#x2F;xxx.pngroot&#x2F;dog&#x2F;xxy.pngroot&#x2F;dog&#x2F;xxz.pngroot&#x2F;cat&#x2F;123.pngroot&#x2F;cat&#x2F;nsdf3.pngroot&#x2F;cat&#x2F;asd932_.png 上面表示数据集已经按类分好，在一个文件夹内是同一类的图片。 12import torchvision.datasets as dsetdset.ImageFolder(root=\"root folder path\", [transform, target_transform]) 参数： root ： 指定图片存储的路径，在下面的例子中是’./data/dogcat_2’ transform： 一个函数，原始图片作为输入，返回一个转换后的图片。 target_transform - 一个函数，输入为target，输出对其的转换。例子，输入的是图片标注的string，输出为word的索引。 返回有以下成员变量: self.classes - 用一个list保存 类名 self.class_to_idx - 类名对应的 索引 self.imgs - 保存(img-path, class) tuple的list 12345import torchvision.datasets as dsetdataset = dset.ImageFolder('./data/dogcat_2') #没有transform，先看看取得的原始图像数据print(dataset.classes) #根据分的文件夹的名字来确定的类别print(dataset.class_to_idx) #按顺序为这些类别定义索引为0,1...print(dataset.imgs) #返回从所有文件夹中得到的图片的路径以及其类别 返回 123['cat', 'dog']&#123;'cat': 0, 'dog': 1&#125;[('./data/dogcat_2/cat/cat.12484.jpg', 0), ('./data/dogcat_2/cat/cat.12485.jpg', 0), ('./data/dogcat_2/cat/cat.12486.jpg', 0), ('./data/dogcat_2/cat/cat.12487.jpg', 0), ('./data/dogcat_2/dog/dog.12496.jpg', 1), ('./data/dogcat_2/dog/dog.12497.jpg', 1), ('./data/dogcat_2/dog/dog.12498.jpg', 1), ('./data/dogcat_2/dog/dog.12499.jpg', 1)] 如果在数据下面又添加了一个类型’others’，那么访问类型的时候返回的就是： 12['cat', 'dog', 'others']&#123;'cat': 0, 'dog': 1, 'others': 2&#125; 查看得到的图片数据： 1234#从返回结果可见得到的数据仍是PIL Image对象print(dataset[0])print(dataset[0][0])print(dataset[0][1]) #得到的是类别0，即cat 返回 123(&lt;PIL.Image.Image image mode=RGB size=497x500 at 0x11D99A9B0&gt;, 0)&lt;PIL.Image.Image image mode=RGB size=497x500 at 0x11DD24278&gt;0 2 torchvision.modelsmodels包含了以下的模型 AlexNet VGG ResNet SqueezeNet DenseNet Inception v3 GoogLeNet 可以随机参数初始化一个模型 1234567import torchvision.models as modelsresnet18 = models.resnet18()alexnet = models.alexnet()vgg16 = models.vgg16()squeezenet = models.squeezenet1_0()densenet = models.densenet161() 此外还提供了预训练的的模型，构造函数里添加pretrained=True 12345import torchvision.models as modelsresnet18 = models.resnet18(pretrained=True)alexnet = models.alexnet(pretrained=True)squeezenet = models.squeezenet1_0(pretrained=True) 所有的预训练模型期待输入同样标准化的数据，例如mini-baches 包括形似(3*H*W)的3通道的RGB图像，H,W最少是224。 图像的范围必须在[0,1]之间，然后使用 mean=[0.485, 0.456, 0.406] and std=[0.229, 0.224, 0.225] 进行标准化。 相关例子 3 torchvision.transforms变换为常用的图像变换，可以通过Compose一起使用。 1transforms.Compose([transforms.CenterCrop(10), transforms.ToTensor()]) 3.1 在PIL格式图片上的转换1class torchivision.transforms.CenterCrop(size) 作用：剪切并返回PIL图片上中心区域参数：size为序列或者整形——输出的中心区域大小。size为(h, w)，size为整数时，则为(size, szie)。 1class torchvision.transforms.ColorJitter(brightness=0, contrast=0,saturation=0,hue=0) 作用：随机改变图片的亮度、对比度和饱和度参数： brightness(亮度，float类型)——调整亮度的程度，亮度因子(brightness_factor)从 [max(0,1-brightness), 1+brightness] 中均匀选取。 contrast(对比度，float类型)——调整对比度的程度，对比度因子(contrast_factor)从 [max(0,1-contrast),1+contrast] 中均匀选取。 saturation(饱和度，float类型)——调整饱和度的程度，饱和度因子(saturation_factor) [max(0,1-saturation),1+saturation] 中均匀选取。 hue(色相，float类型) —— 调整色相的程度，色相因子(hue_factor)从 [-hue,hue] 等均匀选择, 其中hue的大小为 [0, 0.5]。 对比度：对比度指不同颜色之间的差别。对比度越大，不同颜色之间的反差越大，所谓黑白分明，对比度过大，图像就会显得很刺眼。对比度越小，不同颜色之间的反差就越小。亮度：亮度是指照射在景物或者图像上光线的明暗程度，图像亮度增加时，会显得刺眼或耀眼，亮度越小，会显得灰暗。色相：色相就是颜色，调整色相就是调整景物的颜色。饱和度：饱和度指图像颜色的浓度。饱和度越高，颜色越饱满，所谓的青翠欲滴的感觉。饱和度越低，颜色就会越陈旧，惨淡，饱和度为0时，图像就为灰度图像。 1class torchvision.transforms.FiveCrop(size) 作用：将给定的PIL图像剪裁成四个角落区域和中心区域，返回的是一个图像元组(tuple of imgae),所以输入与输出的数量不匹配。参数：size为序列或者整形——输出的中心区域大小。size为(h, w)，size为整数时，则为(size, szie)。 1class torchvision.transforms.Grayscale(num_output_channels=1) 作用：将图片转成灰度图参数：num_output_channels(int) —— (1或者3)，输出图片的通道数量。如果num_output_channels=1, 返回的图片为单通道. 如果 num_output_channels=3,返回的图片为3通道图片，且r=g=b。 1class torchvision.transforms.Pad(padding, fill=0, padding_mode=‘constant’) 作用：对给定的PIL图像的边缘进行填充，填充的数值为给定填充数值参数： padding(int或者tuple)——填充每一个边界。如果只输入了一个int类型的数值，那么这个数值会被用来填充所有的边界，表示填充的宽度多少。如果输入的是tuple且长度为2，那么俩个数值分别被用于填充left/right 和 top/bottom。如果输入的数组为4，那么分别被用来填充left, top ,right 和 bottom边界。 fill (int 或者 tuple) —— 填充的像素的数值为fill。默认为0，如果输入的元组的长度为3，那么分别被用来填充R,G,B通道。这个数值当padding_mode 等于‘constant’ 的时候才会被使用。 padding_mode (string) —— 填充的类型，必须为：constant, edge, reflect or symmetric，默认为 constant。constant: 以常量值进行填充，常量值由 fill 确定。edge: 用图片边界最后一个值进行填充。reflect: pads with reflection of image without repeating the last value on the edge (这句不知怎么翻译，看下面例子)例子: 用俩个元素填充[1,2,3,4], 将会返回[3,2,1,2,3,4,3,2]symmetric: pads with reflection of image repeating the last value on the edge例子：用俩个函数元素填充 [1,2,3,4]，将会返回[2,1,1,2,3,4,4,3] 1class torchvision.transforms.RandomAffine(degrees, translate=None, scale=None) 作用：保持中心不变的对图片进行随机仿射变化参数： degree (旋转，squence或者float或者int) —— 旋转的角度范围。如果角度是数值而不是类似于(min,max)的序列，那么将会转换成(-degree, +degree)序列。设为0则取消旋转。 transalate (平移，tuple，可选) —— 数组，其中元素为代表水平和垂直变换的最大绝对分数。例如translate=(a,b),那么水平位移数值为从(-w*a, w*a)随机采样的，同时垂直位移是从(-h*b, h*b)随机采样的。默认情况下没有平移。 scale (缩放，tuple, 可选) —— 缩放因子区间。若scale=(a,b), 则缩放的值在a&lt;=scale&lt;=b 随机采样。默认情况下没有缩放。 shear (错切，sequence 或者 float 或者 int, 可选) —— 错切的程度。如果错切的程度是一个值，那么将会转换为序列即(—degree, +degree)。默认情况下不使用错切。 resample ({PIL.Image.NEAREST, PIL.Image.BILINEAR, PIL.Image.BICUBIC}, 可选)。 fillcolor(整型) —— 可选择的在输出图片中填充变换以外的区域。(Pillow&gt;=5.0.0) 1class torchvision.transforms.RandomApply(transforms, p=0.5) 作用：随机选取变换中(各种变换存储在列表中)的其中一个，同时给定一定的概率参数： transforms: 变换（list或者tuple） —— 转换的列表 p: (float 类型) —— 概率,选取某个变化需要的概率 1torchvision.transforms.Resize(size,interpolation=2) 作用：将输入的PIL图片转换成给定的尺寸的大小参数： size(sequence 或者 int) —— 需要输出的图片的大小。如果size是类似于(h,w)的序列，输出的尺寸将会跟(h,w)一致。如果size是整型，图片较小的边界将会被置为这个尺寸。例如，如果height-&gt;width, 图片将会被置为 (size*height/width, size) Interpolation (int, 可选) —— 默认为 PIL.Image.BILINEAR 1torch 3.2 在torch.*Tensor上的转换1class torchvision.transforms.Normalize(mean,std) 作用：用均值和标准差对张量图像进行标准化处理。给定n通道的均值(M1, … , Mn) 和标准差(S1, … ,Sn), 这个变化将会归一化根据均值和标准差归一化每个通道值。例如，input[channel] = (input[channel]-mean[channel])/std(channel) 参数： mean (squence) —— 每个通道的均值 std (sequence) —— 每个通道的标准差 3.3 类型转换变换1class torchvision.transforms.ToPILImage(mode=None) 作用：将tensor类型或者ndarray转换成PIL图片，将 C*H*W大小的torch.Tensor或者H\\W*C 大小的numpy矩阵转成PIL图片。参数：如果mode=None，则有一下假设 如果输入为4个通道，mode为RGBA 如果输入为3个通道，mode为RGB 如果输入为2个通道，mode为LA 如果输入为1个通道，mode有数据的类型决定（int,float） 1class torchvision.transforms.ToTensor() 作用：将PIL图像和numpy array转换为tensor 4 参考文献https://www.cnblogs.com/yjphhw/p/9773333.htmlhttps://pytorch.org/docs/stable/torchvisionhttps://blog.csdn.net/Hansry/article/details/84071316https://www.cnblogs.com/wanghui-garcia/p/10649364.html","categories":[{"name":"pytorch","slug":"pytorch","permalink":"http://yoursite.com/categories/pytorch/"}],"tags":[{"name":"torchvision","slug":"torchvision","permalink":"http://yoursite.com/tags/torchvision/"}]},{"title":"Markdown 语法学习","slug":"markdown-语法学习","date":"2020-01-21T07:00:35.000Z","updated":"2020-02-01T03:39:20.000Z","comments":true,"path":"2020/01/21/markdown-语法学习/","link":"","permalink":"http://yoursite.com/2020/01/21/markdown-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/","excerpt":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。","text":"Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为 .md, .markdown。 1.Markdown 标题可以通过设置#的个数来表示标题大小，#的个数对应标题大小一般在#后加一个空格在写文字 示例： 123456# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 效果如下： 一级标题二级标题三级标题四级标题五级标题六级标题 2 Markdown 段落格式2.1 字体加粗的文字左右用两个*包围斜体的文字左右用一个*包围斜体加粗的文字左右用三个*包围删除线的文字左右用两个~包围 示例： 1234**hello world 加粗***hello world 斜体****hello world 斜体加粗***~~hello world 删除线~~ 效果如下：hello world 加粗hello world 斜体hello world 斜体加粗hello world 删除线 2.2 分隔线你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线。不过一般推荐用—- 示例： 12345---**** * *- - -------- 效果如下： 2.3 下划线下划线可以通过 HTML 的 \\&lt;u&gt; 标签来实现 示例： 1&lt;u&gt;hello world 下划线&lt;/u&gt; 2.4 脚注脚注是对文本的表示说明 示例： 1[^要注明的文本] 效果如下：创建脚注格式类似这样 hello。hello: hello world！！！ 3 Markdown 列表Markdown支持有序列表和无序列表 3.1 无序列表无序列表使用星号(*)、加号(+)、减号(-)作为标记。注意要符号后要跟一个空格示例： 1234567891011* 第一项* 第二项* 第三项+ 第一项+ 第二项+ 第三项- 第一项- 第二项- 第三项 效果如下： 第一项 第二项 第三项 第一项 第二项 第三项 第一项 第二项 第三项 3.2 有序列表有序列表使用数字并加上(.)号来表示示例： 1231. 第一项2. 第二项3. 第三项 效果如下： 第一项 第二项 第三项 3.3 列表嵌套有序列表和无序列表可以相会嵌套列表嵌套只需在子列表中的选项添加三个空格即可 示例： 1234561. 一级有序列表内容 * 二级无序列表内容 * 二级无序列表内容2. 一级有序列表内容 * 二级无序列表内容 * 二级无序列表内容 效果如下： 一级有序列表内容 二级无序列表内容 二级无序列表内容 一级有序列表内容 二级无序列表内容 二级无序列表内容 4 Markdown 区块Markdown区块引用在段落开头使用&gt;符号，后面紧跟一个空格嵌套引用在前面多加一个&gt; 示例： 123456&gt; 第一行&gt; 第二行&gt; 第三行&gt; &gt; 第四行&gt; &gt; 第五行&gt; &gt; 第六行 效果如下： 第一行第二行第三行 第四行第五行第六行 5 Markdown 图片基本语法：![图片alt](图片地址 &#39;&#39;图片title&#39;&#39;) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加。 5.1 本地引用可以放在文章所在的目录，文章的目录可以通过配置_config.yml来生成。 1post_asset_folder: true 将_config.yml文件中的配置项post_asset_folder设为true后，执行命令$ hexo new post_name，在source/_posts中会生成文章post_name.md和同名文件夹post_name。将图片资源放在post_name中，文章就可以使用相对路径引用图片资源了。示例： 1![earth](/markdown-语法学习/earth.jpg \"earth\") 但在本地markdown文件有效，部署到浏览器显示不知道为什么无用 5.2 使用官方提供的标签 通过常规的 markdown 语法和相对路径来引用图片和其它资源可能会导致它们在存档页或者主页上显示不正确。在Hexo 2时代，社区创建了很多插件来解决这个问题。但是，随着Hexo 3 的发布，许多新的标签插件被加入到了核心代码中。这使得你可以更简单地在文章中引用你的资源。 示例： 1&#123;% asset_img universe.jpg universe %&#125; 效果如下: 6 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 表头 表头 表头 内容 内容 内容 内容 内容 内容 第二行分割表头和内容。-号 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 示例： 12345姓名|成绩|排名----|:--:|--:小明|98|1小王|90|2小赵|88|3 效果如下： 姓名 成绩 排名 小红 98 1 小赵 60 2 7 超链接语法： 12[超链接名](超链接地址 \"超链接title\")title可加可不加 示例： 12[简书](http://jianshu.com)[百度](http://baidu.com) 效果如下：简书百度 9 代码9.1 单行代码单行代码之间用一个反引号包起来示例：hello world 9.2 多行代码代码块之间分别用三个反引号包起来，且两边的反引号单独占一行并且可以指定一种语言 示例： 123456(&#96;&#96;&#96;) pythonimport sysimport timeprint(&quot;hello world&quot;)(&#96;&#96;&#96;) 其中括号为了防止```发生作用 效果如下： 1234import sysimport timeprint(\"hello world\") 10 公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。 如何修改配置可看解决方法1, 解决方法2 示例 123$$f(x) &#x3D; \\frac&#123;1&#125;&#123;\\sqrt&#123;2\\pi&#125;\\sigma&#125;e^&#123;-\\frac&#123;x^2&#125;&#123;2\\sigma^2&#125;&#125;$$ 效果如下： f(x) = \\frac{1}{\\sqrt{2\\pi}\\sigma}e^{-\\frac{x^2}{2\\sigma^2}}11 流程图等有时间再写 12 快捷键 Ctrl + B：切换为粗体 Ctrl + I：切换为斜体 Ctrl + shift + ]：切换标题（上层） Ctrl + shift + [：切换标题（下层） Ctrl + M：切换数学环境 参考文献https://www.runoob.com/markdown/md-lists.htmlhttps://www.jianshu.com/p/191d1e21f7edhttps://blog.csdn.net/oDianZi1234567/article/details/89323982","categories":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/categories/markdown/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"http://yoursite.com/tags/markdown/"}]}]}